import pandas as pd
import numpy as np
from collections import defaultdict
import heapq
from datetime import datetime, timedelta
import json
from collections import deque

class ParetoTrainRouter:
    """
    Advanced train routing with Pareto-Optimal multi-objective optimization
    Combines O(E log V) Dijkstra with Pareto frontier analysis
    """
    
    def __init__(self, df):
        self.df = df
        self.station_to_id = {}
        self.id_to_station = {}
        self.graph = defaultdict(list)
        self.train_info = {}
        self._build_sparse_graph()
    
    def _build_sparse_graph(self):
        """Build sparse graph with O(n) edges"""
        print("Building optimized sparse graph...")
        
        unique_stations = self.df['Station Code'].unique()
        for idx, station in enumerate(unique_stations):
            self.station_to_id[station] = idx
            self.id_to_station[idx] = station
        
        grouped = self.df.groupby('Train No')
        edge_count = 0
        
        for train_no, train_df in grouped:
            train_df = train_df.sort_values('SEQ').reset_index(drop=True)
            
            self.train_info[train_no] = {
                'name': train_df.iloc[0]['Train Name'],
                'source': train_df.iloc[0]['Source Station'],
                'destination': train_df.iloc[0]['Destination Station'],
                'stations': []
            }
            
            for i in range(len(train_df) - 1):
                curr_row = train_df.iloc[i]
                next_row = train_df.iloc[i + 1]
                
                from_id = self.station_to_id[curr_row['Station Code']]
                to_id = self.station_to_id[next_row['Station Code']]
                
                distance = abs(float(next_row['Distance']) - float(curr_row['Distance']))
                duration = self._calculate_duration(distance)
                
                station_info = {
                    'station': curr_row['Station Code'],
                    'seq': int(curr_row['SEQ']),
                    'arrival': curr_row['Arrival time'],
                    'departure': curr_row['Departure Time'],
                    'distance': float(curr_row['Distance'])
                }
                self.train_info[train_no]['stations'].append(station_info)
                
                edge = {
                    'to_id': to_id,
                    'train_no': train_no,
                    'departure': curr_row['Departure Time'],
                    'arrival': next_row['Arrival time'],
                    'distance': distance,
                    'duration': duration,
                    'from_seq': int(curr_row['SEQ']),
                    'to_seq': int(next_row['SEQ']),
                    'seat_available': curr_row['Seat Availability']
                }
                
                self.graph[from_id].append(edge)
                edge_count += 1
            
            last_row = train_df.iloc[-1]
            self.train_info[train_no]['stations'].append({
                'station': last_row['Station Code'],
                'seq': int(last_row['SEQ']),
                'arrival': last_row['Arrival time'],
                'departure': last_row['Departure Time'],
                'distance': float(last_row['Distance'])
            })
        
        print(f"‚úì Graph built: {len(self.station_to_id)} stations, {edge_count} edges")
    
    def find_direct_trains(self, source, destination):
        """Find all direct trains"""
        direct_trains = []
        
        for train_no, info in self.train_info.items():
            stations = [s['station'] for s in info['stations']]
            if source in stations and destination in stations:
                src_idx = stations.index(source)
                dst_idx = stations.index(destination)
                if dst_idx > src_idx:
                    direct_trains.append(train_no)
        
        return direct_trains
    
    def generate_all_routes(self, source, destination, max_transfers=3):
        """
        Generate comprehensive route set using multi-strategy search
        Returns: List of all feasible routes (200-300 routes)
        """
        source_id = self.station_to_id[source]
        dest_id = self.station_to_id[destination]
        
        all_routes = []
        
        print("\nüîç Phase 1: Generating comprehensive route set...")
        
        # Strategy 1: Direct routes (0 transfers)
        print("  ‚Üí Finding direct routes...")
        direct_routes = self._find_direct_routes(source_id, dest_id)
        all_routes.extend(direct_routes)
        print(f"    Found {len(direct_routes)} direct routes")
        
        # Strategy 2: Single-transfer routes (1 transfer)
        if max_transfers >= 1:
            print("  ‚Üí Finding single-transfer routes...")
            single_transfer = self._find_single_transfer_routes(source_id, dest_id)
            all_routes.extend(single_transfer)
            print(f"    Found {len(single_transfer)} single-transfer routes")
        
        # Strategy 3: Multi-transfer routes (2-3 transfers)
        if max_transfers >= 2:
            print("  ‚Üí Finding multi-transfer routes...")
            multi_transfer = self._find_multi_transfer_routes(source_id, dest_id, max_transfers)
            all_routes.extend(multi_transfer)
            print(f"    Found {len(multi_transfer)} multi-transfer routes")
        
        print(f"\n‚úì Total routes generated: {len(all_routes)}")
        return all_routes
    
    def _find_direct_routes(self, source_id, dest_id):
        """Find all direct train routes"""
        routes = []
        
        for edge in self.graph[source_id]:
            if edge['to_id'] == dest_id:
                path = [{
                    'train_no': edge['train_no'],
                    'from': self.id_to_station[source_id],
                    'to': self.id_to_station[dest_id],
                    'departure': edge['departure'],
                    'arrival': edge['arrival'],
                    'distance': edge['distance'],
                    'duration': edge['duration'],
                    'wait_before': 0,
                    'seat_available': edge['seat_available']
                }]
                routes.append(path)
        
        return routes
    
    def _find_single_transfer_routes(self, source_id, dest_id, max_routes=100):
        """Find routes with exactly 1 transfer via major junctions"""
        routes = []
        visited_junctions = set()
        
        # Find intermediate stations (junctions)
        for edge1 in self.graph[source_id]:
            junction_id = edge1['to_id']
            
            if junction_id in visited_junctions or junction_id == dest_id:
                continue
            visited_junctions.add(junction_id)
            
            # Find connections from junction to destination
            for edge2 in self.graph[junction_id]:
                if edge2['to_id'] == dest_id:
                    # Check if different trains
                    if edge1['train_no'] != edge2['train_no']:
                        wait_time = self._calculate_wait_time(edge1['arrival'], edge2['departure'])
                        
                        # Realistic transfer time: 30 min to 8 hours
                        if 0.5 <= wait_time <= 8:
                            path = [
                                {
                                    'train_no': edge1['train_no'],
                                    'from': self.id_to_station[source_id],
                                    'to': self.id_to_station[junction_id],
                                    'departure': edge1['departure'],
                                    'arrival': edge1['arrival'],
                                    'distance': edge1['distance'],
                                    'duration': edge1['duration'],
                                    'wait_before': 0,
                                    'seat_available': edge1['seat_available']
                                },
                                {
                                    'train_no': edge2['train_no'],
                                    'from': self.id_to_station[junction_id],
                                    'to': self.id_to_station[dest_id],
                                    'departure': edge2['departure'],
                                    'arrival': edge2['arrival'],
                                    'distance': edge2['distance'],
                                    'duration': edge2['duration'],
                                    'wait_before': wait_time,
                                    'seat_available': edge2['seat_available']
                                }
                            ]
                            routes.append(path)
                            
                            if len(routes) >= max_routes:
                                return routes
        
        return routes
    
    def _find_multi_transfer_routes(self, source_id, dest_id, max_transfers, max_routes=100):
        """Find routes with 2-3 transfers using BFS"""
        routes = []
        queue = deque()
        queue.append((source_id, [], 0, 0))
        visited = set()
        
        while queue and len(routes) < max_routes:
            current_id, path, transfers, total_dist = queue.popleft()
            
            if current_id == dest_id and path:
                routes.append(path[:])
                continue
            
            if transfers >= max_transfers or total_dist > 3000:
                continue
            
            state = (current_id, transfers)
            if state in visited:
                continue
            visited.add(state)
            
            for edge in self.graph[current_id]:
                next_id = edge['to_id']
                
                wait_time = 0
                is_transfer = False
                
                if path:
                    last_train = path[-1]['train_no']
                    if last_train != edge['train_no']:
                        is_transfer = True
                        wait_time = self._calculate_wait_time(path[-1]['arrival'], edge['departure'])
                        if wait_time < 0.5 or wait_time > 8:
                            continue
                
                new_segment = {
                    'train_no': edge['train_no'],
                    'from': self.id_to_station[current_id],
                    'to': self.id_to_station[next_id],
                    'departure': edge['departure'],
                    'arrival': edge['arrival'],
                    'distance': edge['distance'],
                    'duration': edge['duration'],
                    'wait_before': wait_time,
                    'seat_available': edge['seat_available']
                }
                
                new_path = path + [new_segment]
                new_transfers = transfers + (1 if is_transfer else 0)
                new_dist = total_dist + edge['distance']
                
                queue.append((next_id, new_path, new_transfers, new_dist))
        
        return routes
    
    def calculate_route_objectives(self, path):
        """
        Calculate 5 optimization objectives for a route
        Returns: (time, cost, transfers, seat_prob, safety_score)
        """
        # Objective 1: Total journey time (minimize)
        total_time = sum(seg['duration'] + seg['wait_before'] for seg in path)
        
        # Objective 2: Total cost (minimize) - ‚Çπ1 per km
        total_distance = sum(seg['distance'] for seg in path)
        total_cost = total_distance * 1.0
        
        # Objective 3: Number of transfers (minimize)
        transfers = len(path) - 1
        
        # Objective 4: Seat availability probability (maximize)
        # Average seat availability across all segments
        seat_prob = np.mean([seg['seat_available'] for seg in path]) * 100
        
        # Objective 5: Safety score (maximize)
        # Based on: fewer transfers = safer, direct trains = safer
        base_safety = 100
        transfer_penalty = transfers * 5  # -5 points per transfer
        safety_score = max(base_safety - transfer_penalty, 50)
        
        # Add bonus for popular express trains (train numbers < 15000)
        for seg in path:
            if int(seg['train_no']) < 15000:
                safety_score = min(safety_score + 5, 100)
                break
        
        return {
            'time': total_time * 60,  # Convert to minutes
            'cost': total_cost,
            'transfers': transfers,
            'seat_prob': seat_prob,
            'safety_score': safety_score,
            'distance': total_distance
        }
    
    def pareto_optimize(self, routes):
        """
        Apply Pareto optimization to find non-dominated routes
        Returns: Pareto-optimal routes (typically 20-40% of total)
        """
        print("\nüéØ Phase 2: Pareto optimization analysis...")
        
        # Calculate objectives for all routes
        route_objectives = []
        for route in routes:
            obj = self.calculate_route_objectives(route)
            route_objectives.append({
                'route': route,
                'objectives': obj
            })
        
        # Find Pareto front
        pareto_front = []
        
        for i, route_i in enumerate(route_objectives):
            is_dominated = False
            obj_i = route_i['objectives']
            
            for j, route_j in enumerate(route_objectives):
                if i == j:
                    continue
                
                obj_j = route_j['objectives']
                
                # Check if route_j dominates route_i
                if self._dominates(obj_j, obj_i):
                    is_dominated = True
                    break
            
            if not is_dominated:
                pareto_front.append(route_i)
        
        print(f"‚úì Pareto front size: {len(pareto_front)} / {len(routes)} routes")
        return pareto_front
    
    def _dominates(self, obj_a, obj_b):
        """
        Check if objective set A dominates B
        A dominates B if A is better or equal in all objectives and strictly better in at least one
        
        Minimize: time, cost, transfers
        Maximize: seat_prob, safety_score
        """
        # A must be better or equal in all objectives
        better_or_equal = (
            obj_a['time'] <= obj_b['time'] and
            obj_a['cost'] <= obj_b['cost'] and
            obj_a['transfers'] <= obj_b['transfers'] and
            obj_a['seat_prob'] >= obj_b['seat_prob'] and
            obj_a['safety_score'] >= obj_b['safety_score']
        )
        
        # A must be strictly better in at least one objective
        strictly_better = (
            obj_a['time'] < obj_b['time'] or
            obj_a['cost'] < obj_b['cost'] or
            obj_a['transfers'] < obj_b['transfers'] or
            obj_a['seat_prob'] > obj_b['seat_prob'] or
            obj_a['safety_score'] > obj_b['safety_score']
        )
        
        return better_or_equal and strictly_better
    
    def _get_route_fingerprint(self, route):
        """Generate a unique, hashable fingerprint for a route."""
        return tuple(segment['train_no'] for segment in route)

    def select_optimal_routes(self, pareto_front, num_routes=15):
        """
        Select UP TO 15 diverse optimal routes from Pareto front
        Strategy: Show MAXIMUM variety to let user make their own choice
        
        Categories with MORE alternatives:
        - FASTEST (1 route)
        - CHEAPEST (1 route) 
        - DIRECT (1 route)
        - Plus 12 MORE diverse Pareto-optimal alternatives
        """
        print(f"\nüèÜ Phase 3: Selecting up to {num_routes} diverse optimal routes...")
        
        if len(pareto_front) == 0:
            return [], []
        
        selected_routes = []
        categories = []
        route_fingerprints = set()  # Track unique routes by fingerprint
        
        # Helper to add unique route
        def add_route(route, category):
            fingerprint = self._get_route_fingerprint(route['route'])
            if fingerprint not in route_fingerprints and len(selected_routes) < num_routes:
                selected_routes.append(route)
                categories.append(category)
                route_fingerprints.add(fingerprint)
                return True
            return False
        
        # Sort by different objectives
        sorted_by_time = sorted(pareto_front, key=lambda x: x['objectives']['time'])
        sorted_by_cost = sorted(pareto_front, key=lambda x: x['objectives']['cost'])
        sorted_by_transfers = sorted(pareto_front, key=lambda x: x['objectives']['transfers'])
        sorted_by_seats = sorted(pareto_front, key=lambda x: x['objectives']['seat_prob'], reverse=True)
        sorted_by_safety = sorted(pareto_front, key=lambda x: x['objectives']['safety_score'], reverse=True)
        
        # STEP 1: Add the absolute best in each primary category (5 routes)
        print("  ‚Üí Adding best routes in each category...")
        
        if sorted_by_time:
            add_route(sorted_by_time[0], 'FASTEST ‚ö°')
        
        if sorted_by_cost:
            add_route(sorted_by_cost[0], 'CHEAPEST üí∞')
        
        if sorted_by_transfers:
            add_route(sorted_by_transfers[0], 'MOST DIRECT üöÇ')
        
        if sorted_by_seats:
            add_route(sorted_by_seats[0], 'BEST SEATS üí∫')
        
        if sorted_by_safety:
            add_route(sorted_by_safety[0], 'SAFEST üõ°Ô∏è')
        
        # STEP 2: Add 2nd and 3rd best in time and cost (high priority)
        print("  ‚Üí Adding runner-up fast/cheap routes...")
        
        for i in range(1, min(3, len(sorted_by_time))):
            if add_route(sorted_by_time[i], f'FAST #{i+1} ‚ö°'):
                pass
        
        for i in range(1, min(3, len(sorted_by_cost))):
            if add_route(sorted_by_cost[i], f'CHEAP #{i+1} üí∞'):
                pass
        
        # STEP 3: Add balanced routes (good trade-offs across all metrics)
        print("  ‚Üí Adding balanced trade-off routes...")
        
        # Normalize objectives to calculate balanced score
        if pareto_front:
            times = [r['objectives']['time'] for r in pareto_front]
            costs = [r['objectives']['cost'] for r in pareto_front]
            transfers_list = [r['objectives']['transfers'] for r in pareto_front]
            seats = [r['objectives']['seat_prob'] for r in pareto_front]
            safety = [r['objectives']['safety_score'] for r in pareto_front]
            
            min_time, max_time = min(times), max(times)
            min_cost, max_cost = min(costs), max(costs)
            min_transfers, max_transfers = min(transfers_list), max(transfers_list)
            min_seats, max_seats = min(seats), max(seats)
            min_safety, max_safety = min(safety), max(safety)
            
            for route in pareto_front:
                obj = route['objectives']
                
                # Normalize to 0-1 scale
                norm_time = (max_time - obj['time']) / (max_time - min_time + 0.001)
                norm_cost = (max_cost - obj['cost']) / (max_cost - min_cost + 0.001)
                norm_transfers = (max_transfers - obj['transfers']) / (max_transfers - min_transfers + 0.001)
                norm_seats = (obj['seat_prob'] - min_seats) / (max_seats - min_seats + 0.001)
                norm_safety = (obj['safety_score'] - min_safety) / (max_safety - min_safety + 0.001)
                
                # Balanced score: equal weight to all objectives
                route['balanced_score'] = (
                    norm_time * 0.25 +
                    norm_cost * 0.25 +
                    norm_transfers * 0.20 +
                    norm_seats * 0.15 +
                    norm_safety * 0.15
                )
            
            sorted_balanced = sorted(pareto_front, key=lambda x: x['balanced_score'], reverse=True)
            
            for i, route in enumerate(sorted_balanced[:5]):
                if add_route(route, f'BALANCED #{i+1} ‚öñÔ∏è'):
                    pass
        
        # STEP 4: Fill remaining slots with most diverse Pareto-optimal routes
        print("  ‚Üí Adding diverse Pareto-optimal alternatives...")
        
        # Strategy: Pick routes that maximize diversity in objective space
        remaining_front = [r for r in pareto_front if self._get_route_fingerprint(r['route']) not in route_fingerprints]
        
        if remaining_front:
            # Sort by different composite scores for diversity
            composite_scores = []
            for route in remaining_front:
                obj = route['objectives']
                
                # Different composite priorities
                time_cost_score = obj['time'] * 0.6 + obj['cost'] * 0.4
                cost_time_score = obj['cost'] * 0.6 + obj['time'] * 0.4
                transfer_time_score = obj['transfers'] * 400 + obj['time'] * 0.3
                
                route['time_cost_score'] = time_cost_score
                route['cost_time_score'] = cost_time_score
                route['transfer_time_score'] = transfer_time_score
            
            # Add top routes from each composite ranking
            by_time_cost = sorted(remaining_front, key=lambda x: x['time_cost_score'])
            by_cost_time = sorted(remaining_front, key=lambda x: x['cost_time_score'])
            by_transfer_time = sorted(remaining_front, key=lambda x: x['transfer_time_score'])
            
            alt_num = 1
            for route in by_time_cost[:3]:
                if add_route(route, f'ALTERNATIVE #{alt_num} üîÑ'):
                    alt_num += 1
            
            for route in by_cost_time[:3]:
                if add_route(route, f'ALTERNATIVE #{alt_num} üîÑ'):
                    alt_num += 1
            
            for route in by_transfer_time[:3]:
                if add_route(route, f'ALTERNATIVE #{alt_num} üîÑ'):
                    alt_num += 1
        
        # STEP 5: If still space, add remaining Pareto-optimal routes
        if len(selected_routes) < num_routes:
            print("  ‚Üí Adding remaining Pareto-optimal routes...")
            remaining = [r for r in pareto_front if self._get_route_fingerprint(r['route']) not in route_fingerprints]
            
            for i, route in enumerate(remaining[:num_routes - len(selected_routes)]):
                add_route(route, f'OPTIMAL #{len(selected_routes) - 4} üéØ')
        
        print(f"‚úì Selected {len(selected_routes)} diverse optimal routes for comparison")
        return selected_routes, categories
    
    def _calculate_duration(self, distance):
        """Calculate realistic travel duration"""
        if distance > 1800:
            return distance / 58
        elif distance > 1000:
            return distance / 60
        elif distance > 500:
            return distance / 55
        elif distance > 300:
            return distance / 50
        elif distance > 150:
            return distance / 45
        else:
            return distance / 38
    
    def _calculate_wait_time(self, arrival_time, departure_time):
        """Calculate waiting time in hours"""
        try:
            fmt = '%H:%M:%S'
            t1 = datetime.strptime(arrival_time, fmt)
            t2 = datetime.strptime(departure_time, fmt)
            if t2 < t1:
                t2 += timedelta(days=1)
            return (t2 - t1).total_seconds() / 3600
        except:
            return 1.0
    
    def format_duration(self, minutes):
        """Format duration as HH:MM"""
        h = int(minutes // 60)
        m = int(minutes % 60)
        return f"{h}h {m}m"

def get_routes_data(source, destination, max_transfers):
    # Load data
    try:
        df = pd.read_csv('Train_details.csv')
        df = df[df['Train No'].astype(str).str.len() == 5].copy()
        df['Seat Availability'] = np.random.choice([0, 1], size=len(df), p=[0.2, 0.8])
    except FileNotFoundError:
        return {"error": "Could not find 'Train_details.csv'."}
    except Exception as e:
        return {"error": str(e)}

    # Initialize router
    router = ParetoTrainRouter(df)

    if source not in router.station_to_id:
        return {"error": f"Station '{source}' not found."}
    if destination not in router.station_to_id:
        return {"error": f"Station '{destination}' not found."}
    if source == destination:
        return {"error": "Origin and destination must be different."}

    # PIPELINE: Generate ‚Üí Optimize ‚Üí Select
    all_routes = router.generate_all_routes(source, destination, max_transfers)

    if not all_routes:
        return {"error": "No routes found!"}

    pareto_front = router.pareto_optimize(all_routes)
    optimal_routes, categories = router.select_optimal_routes(pareto_front, num_routes=15)

    # Save and get JSON data
    json_data = save_results(router, optimal_routes, categories,
                             f"{source}_to_{destination}_pareto_routes.csv",
                             f"{source}_to_{destination}_pareto_routes.json",
                             all_routes, pareto_front, source, destination)
    
    return json_data

def main():
    print("\n" + "="*80)
    print(" PARETO-OPTIMAL TRAIN ROUTE OPTIMIZER")
    print(" Multi-Objective Optimization: Time | Cost | Transfers | Comfort | Safety")
    print("="*80)

    # Get user input
    source = input("Enter origin station code (e.g., PGT, CSMT): ").strip().upper()
    destination = input("Enter destination station code (e.g., KOTA, NGP): ").strip().upper()
    
    while True:
        try:
            max_transfers = int(input("Maximum transfers allowed (0-3): "))
            if 0 <= max_transfers <= 3:
                break
            print("Please enter 0-3")
        except ValueError:
            print("Invalid input")

    print("\n" + "="*80)
    print("STARTING PARETO OPTIMIZATION PIPELINE")
    print("="*80)
    
    results = get_routes_data(source, destination, max_transfers)

    if "error" in results:
        print(f"Error: {results['error']}")
        return

    # For console output, we can re-create some of the original display logic
    # This is a simplified version of the original output.
    print("\n" + "="*80)
    print("ALL OPTIMAL ROUTES - COMPARE & CHOOSE YOUR PREFERENCE")
    print("="*80)

    print("\nüìä QUICK COMPARISON TABLE")
    print("-" * 80)
    print(f"{'Route':<8} {'Category':<20} {'Time':<10} {'Cost':<8} {'Transfer':<9} {'Seats':<8} {'Safety':<7}")
    print("-" * 80)

    router = ParetoTrainRouter(pd.read_csv('Train_details.csv')) # Re-init for format_duration
    for route_data in results['routes']:
        obj = route_data['objectives']
        time_str = router.format_duration(obj['time'])
        print(f"{route_data['route_id']:<8} {route_data['category']:<20} {time_str:<10} ‚Çπ{obj['cost']:<7.0f} "
              f"{obj['transfers']:<9} {obj['seat_prob']:<7.1f}% {obj['safety_score']:<6.0f}/100")

    print("-" * 80)
    print("\nüíæ Results also saved to JSON and CSV files.")


def save_results(router, optimal_routes, categories, csv_file, json_file,
                 all_routes, pareto_front, source, destination):
    """Save optimization results to CSV and JSON, and return JSON data"""

    # Prepare CSV data
    csv_rows = []
    json_data = {
        'metadata': {
            'source': source,
            'destination': destination,
            'total_routes_generated': len(all_routes),
            'pareto_front_size': len(pareto_front),
            'optimal_routes_count': len(optimal_routes)
        },
        'routes': []
    }

    for idx, (route_data, category) in enumerate(zip(optimal_routes, categories), 1):
        route = route_data['route']
        obj = route_data['objectives']

        route_json = {
            'route_id': f"ROUTE_{idx:02d}",
            'category': category,
            'objectives': obj,
            'segments': []
        }

        for seg_num, segment in enumerate(route, 1):
            train_name = router.train_info[segment['train_no']]['name']

            csv_rows.append({
                'Route ID': f"ROUTE_{idx:02d}",
                'Category': category,
                'Segment': seg_num,
                'Train Number': segment['train_no'],
                'Train Name': train_name,
                'From': segment['from'],
                'To': segment['to'],
                'Departure': segment['departure'],
                'Arrival': segment['arrival'],
                'Distance (km)': round(segment['distance'], 2),
                'Duration (min)': round(segment['duration'] * 60, 2),
                'Wait Before (min)': round(segment['wait_before'] * 60, 2),
                'Seat Available': segment['seat_available'],
                'Total Time (min)': round(obj['time'], 2),
                'Total Cost (‚Çπ)': round(obj['cost'], 2),
                'Total Transfers': obj['transfers'],
                'Seat Probability (%)': round(obj['seat_prob'], 2),
                'Safety Score': round(obj['safety_score'], 2)
            })

            route_json['segments'].append({
                'train_no': segment['train_no'],
                'train_name': train_name,
                'from': segment['from'],
                'to': segment['to'],
                'departure': segment['departure'],
                'arrival': segment['arrival'],
                'distance': round(segment['distance'], 2),
                'duration_min': round(segment['duration'] * 60, 2),
                'wait_min': round(segment['wait_before'] * 60, 2)
            })

        json_data['routes'].append(route_json)

    # Save CSV
    df_out = pd.DataFrame(csv_rows)
    df_out.to_csv(csv_file, index=False)

    # Save JSON file
    with open(json_file, 'w') as f:
        json.dump(json_data, f, indent=2)

    return json_data

if __name__ == "__main__":
    from collections import deque
    main()